# 병사관리

[병사관리.html](./병사관리문제/병사관리.html)

### **1. 문제 분석 (Problem Analysis)**

- 병사들을 추가한다
    - 병사 정보 (ID, 소속팀, 평판점수)
- 함수1 ) 병사를 추가
- 함수2 ) 병사를 삭제
- 함수3 ) ID로 병사를 찾고, 평판점수 변경
    - 평판점수는 변경되더라도 1~5 사이 값을 가져야됨
- 함수4 ) 팀에 소속된 모든 병사의 평판점수 변경
- 함수 5 ) 팀 하나를 주면, 팀에서 평판 점수가 가장 높은 병사의 ID 반환
    - 평판 점수가 같으면, ID가 큰 병사 반환

### **1-1. 문제 요약 (Summary)**

- hire → 100,000
- fire → 100,000
- updateSoldier → 100,000
- updateTeam → 100,000
- bestSoldier → 100

### **1-2. 핵심 요구사항 및 접근 전략 (Core Requirements & Strategy)**

- CUD는 100,000으로 매우 많다 → Linked List를 사용하자
- Read는 100번으로 매우 적다 → Read는 순차탐색 해도됨 (set 필요없음)

---

### **2. 핵심 알고리즘 및 자료구조 (Algorithm & Data Structure)**

- **주요 알고리즘:** `정적할당`, `Double Linked List`, `DP`
- **선택 이유:**
    - 일단 팀이 5개니깐, 5개 리스트가 필요하다
    - 스코어도 1~5밖에 안된다. 스코어도 5개씩 만들어서 bestSoldier를 찾을때 가지치기를  해보자
        - DP를 이용해서 2차원 배열 (팀 * 스코어) 25개로 표현해보자
    - 배운점 ) 정적할당된 Array를 이중 연결 리스트로 나타낼 수 있다
    - 정적할당 이중 연결 리스트
        - hire → O(1)
        - fire → O(1)
        - updateSoldier → O(1)
            - 정적할당을 이용하면 ID가 idx이므로 이중 연결 리스트라도 O(1)에 접근 가능
        - updateTeam → O(1)
            - DP 2차원배열의 이중 연결 리스트 전체를 옮기는데 head와 tail 부분만 바꾸면됨
        - bestSoldier → O(N)
            - dp 배열중 1개를 순차순회 하면됨
            - N=100,000이긴 한데, dp로 가지치기를 해서 평균 시간복잡도는 훨씬 낮을거임

---

### **3. 코드 (Source Code)**

```cpp
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>

#define CMD_INIT 1
#define CMD_HIRE 2
#define CMD_FIRE 3
#define CMD_UPDATE_SOLDIER 4
#define CMD_UPDATE_TEAM 5
#define CMD_BEST_SOLDIER 6

extern void init();
extern void hire(int mID, int mTeam, int mScore);
extern void fire(int mID);
extern void updateSoldier(int mID, int mScore);
extern void updateTeam(int mTeam, int mChangeScore);
extern int bestSoldier(int mTeam);

/////////////////////////////////////////////////////////////////////////
#include<iostream>
using namespace std;
/////////////////////////////////////////////////////////////////////////

static bool run()
{
	int numQuery;

	int mID, mTeam, mScore, mChangeScore;

	int userAns, ans;

	bool isCorrect = false;

	scanf("%d", &numQuery);

	for (int i = 0; i < numQuery; ++i)
	{
		int cmd;
		scanf("%d", &cmd);
		switch (cmd)
		{
		case CMD_INIT:
			init();
			isCorrect = true;
			break;
		case CMD_HIRE:
			scanf("%d %d %d", &mID, &mTeam, &mScore);
			hire(mID, mTeam, mScore);
			break;
		case CMD_FIRE:
			scanf("%d", &mID);
			fire(mID);
			break;
		case CMD_UPDATE_SOLDIER:
			scanf("%d %d", &mID, &mScore);
			updateSoldier(mID, mScore);
			break;
		case CMD_UPDATE_TEAM:
			scanf("%d %d", &mTeam, &mChangeScore);
			updateTeam(mTeam, mChangeScore);
			break;
		case CMD_BEST_SOLDIER:
			scanf("%d", &mTeam);
			userAns = bestSoldier(mTeam);
			scanf("%d", &ans);
			if (userAns != ans)
			{
				isCorrect = false;
			}
			break;
		default:
			isCorrect = false;
			break;
		}
		// if (!isCorrect) cout << "##" << i + 1 << endl;
		// else cout << "#" << i + 1 << endl;
	}

	return isCorrect;
}

int main()
{
	setbuf(stdout, NULL);
	freopen("input.txt", "r", stdin);

	int T, MARK;
	scanf("%d %d", &T, &MARK);

	for (int tc = 1; tc <= T; tc++)
	{
		int score = run() ? MARK : 0;
		printf("#%d %d\n", tc, score);
	}

	return 0;
}

/////////////////////////////////////////////////
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int MAX_TEAM = 5;
const int MAX_SCORE = 5;
const int MAX_NODE = 100'000;

struct Node{ // 정적할당을 위한 노드 정의
	int id, team; // team필드는 updateSoldier할때 id로 team번호를 알아야될 때 사용
	Node* prev;
	Node* next;
};

struct List { // dp의 원소 정의
	Node head;
	Node tail;

	static void link(Node* a, Node* b) { // 우선 link부터 정의
		a->next = b;
		b->prev = a;
	}

	static void erase(Node* cur) {
		link(cur->prev, cur->next);
	}

	void init() {
		link(&head, &tail);
	}

	void push_back(Node* cur) {
		link(tail.prev, cur);
		link(cur, &tail);
	}

	bool empty() {
		return (head.next == &tail);
	}
};

Node nodeList[MAX_NODE + 4]; // 이중연결리스트 노드 정적할당
List teamScore[MAX_TEAM + 1][MAX_SCORE + 1]; // dp로 25개 이중연결리스트 유지

void init()
{
	for (int i = 1; i <= MAX_TEAM; i++) {
		for (int j = 1; j <= MAX_SCORE; j++) {
			teamScore[i][j].init();
		}
	}
}

void hire(int mID, int mTeam, int mScore)
{
	nodeList[mID].id = mID;
	nodeList[mID].team = mTeam;
	teamScore[mTeam][mScore].push_back(&nodeList[mID]);
}

void fire(int mID)
{
	List::erase(&nodeList[mID]);
}

void updateSoldier(int mID, int mScore)
{
	List::erase(&nodeList[mID]);
	teamScore[nodeList[mID].team][mScore].push_back(&nodeList[mID]);
}

void updateTeam(int mTeam, int mChangeScore)
{
	if (mChangeScore == 0) return;
  else if(mChangeScore < 0) {
    for (int i = 2; i <= MAX_SCORE; i++) { // 디버그 : i = 1일때는 스코어가 감소해도 변화가 없다 -> 넘어가야됨
      int nextScore = i + mChangeScore;
      if (nextScore < 1) nextScore = 1;

      if (!teamScore[mTeam][i].empty()) {
        List::link(teamScore[mTeam][nextScore].tail.prev, teamScore[mTeam][i].head.next);
        List::link(teamScore[mTeam][i].tail.prev, &teamScore[mTeam][nextScore].tail);
        List::link(&teamScore[mTeam][i].head, &teamScore[mTeam][i].tail);
      }
	  }
  } else {
    for (int i = MAX_SCORE -1; i >= 1; i--) { // 디버그 : mChangeScosre가 1인 경우 1부터 진행하면 이전에 옮긴 노드가 또 다시 올라가는 문제 발생
      int nextScore = i + mChangeScore;
      if (nextScore > 5) nextScore = 5;

      if (!teamScore[mTeam][i].empty()) {
        List::link(teamScore[mTeam][nextScore].tail.prev, teamScore[mTeam][i].head.next);
        List::link(teamScore[mTeam][i].tail.prev, &teamScore[mTeam][nextScore].tail);
        List::link(&teamScore[mTeam][i].head, &teamScore[mTeam][i].tail);
      }
	  }
  }
	
}

int bestSoldier(int mTeam)
{
	int maxIdx = -1;
	for (int i = 5; i >= 1; i--) {
		if (!teamScore[mTeam][i].empty()) {
			maxIdx = i;
			break;
		}
	}

	int maxId = -1;
	for (Node* cur = teamScore[mTeam][maxIdx].head.next; cur != &(teamScore[mTeam][maxIdx].tail); cur = cur->next) {
		maxId = max(maxId, cur->id);
	}
	
	return maxId;
}
```

---

### **4. 코드 설명 (Code Description)**

- 주석참고

---

### **5. 시간/공간 복잡도 분석 (Complexity Analysis)**

---

### **6. 어려웠던 점 및 배운 점 (Challenges & Key Takeaways)**

- CUD 연산이 많으면 연결 리스트를 고려해보자
- 정적 할당으로 이중 연결리스트를 구현해서 Update를 O(1)만에 구현해보자
    - list 삭제는 순차 탐색시 O(n)인데 id로 위치를 바로 찾을 수 있으면 O(1)에 가능하다
- DP를 이용해서 점수가 가장 높은 병사를 고를때 점수가 낮은 병사를 가지치기 해보자
    - O(N) 순차 탐색이라도 평균적으로 1/5로 시간이 줄어든다